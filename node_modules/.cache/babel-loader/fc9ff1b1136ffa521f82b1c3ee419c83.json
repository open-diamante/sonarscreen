{"ast":null,"code":"function _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n/* eslint-disable react/no-find-dom-node */\n\n\nimport React, { Component, useEffect, useMemo, useRef, useState } from 'react';\nimport { findDOMNode } from 'react-dom';\nimport { findScrollParent, findScrollParents, isNodeAfterScroll, isNodeBeforeScroll } from '../../utils';\nimport { Box } from '../Box';\n\nvar Ref = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(Ref, _Component);\n\n  function Ref() {\n    return _Component.apply(this, arguments) || this;\n  }\n\n  var _proto = Ref.prototype;\n\n  _proto.render = function render() {\n    var children = this.props.children;\n    return children;\n  };\n\n  return Ref;\n}(Component);\n\nvar InfiniteScroll = function InfiniteScroll(_ref) {\n  var children = _ref.children,\n      _ref$items = _ref.items,\n      items = _ref$items === void 0 ? [] : _ref$items,\n      onMore = _ref.onMore,\n      renderMarker = _ref.renderMarker,\n      replace = _ref.replace,\n      showIndex = _ref.show,\n      _ref$step = _ref.step,\n      step = _ref$step === void 0 ? 50 : _ref$step; // item index to be made visible initially\n\n  var _useState = useState(showIndex),\n      show = _useState[0],\n      setShow = _useState[1]; // the last page we have items for\n\n\n  var lastPage = useMemo(function () {\n    return Math.floor(items.length / step);\n  }, [items.length, step]); // the first page we are displaying\n\n  var _useState2 = useState(0),\n      beginPage = _useState2[0],\n      setBeginPage = _useState2[1]; // the last page we are displaying\n\n\n  var _useState3 = useState(show ? Math.floor((show + step) / step) - 1 : 0),\n      endPage = _useState3[0],\n      setEndPage = _useState3[1]; // how tall we've measured a page to be\n\n\n  var _useState4 = useState(),\n      pageHeight = _useState4[0],\n      setPageHeight = _useState4[1]; // how much area a page requires\n\n\n  var _useState5 = useState(),\n      pageArea = _useState5[0],\n      setPageArea = _useState5[1]; // whether the items are laid out in a grid instead of linearly\n\n\n  var _useState6 = useState(),\n      multiColumn = _useState6[0],\n      setMultiColumn = _useState6[1]; // what we're waiting for onMore to give us\n\n\n  var _useState7 = useState(0),\n      pendingLength = _useState7[0],\n      setPendingLength = _useState7[1];\n\n  var belowMarkerRef = useRef();\n  var firstPageItemRef = useRef();\n  var lastPageItemRef = useRef();\n  var showRef = useRef(); // calculating space based on where the first and last items being displayed\n  // are located\n\n  useEffect(function () {\n    if (firstPageItemRef.current && lastPageItemRef.current && !pageHeight) {\n      /* eslint-disable react/no-find-dom-node */\n      var beginRect = firstPageItemRef.current.getBoundingClientRect ? firstPageItemRef.current.getBoundingClientRect() : findDOMNode(firstPageItemRef.current).getBoundingClientRect();\n      var endRect = lastPageItemRef.current.getBoundingClientRect ? lastPageItemRef.current.getBoundingClientRect() : findDOMNode(lastPageItemRef.current).getBoundingClientRect(); // Need to adjust for cases such as show where first and last page item\n      // refs can be much larger than the step.\n\n      var initialPage = show ? Math.floor(show / step) : 0;\n      var nextPageHeight = (endRect.top + endRect.height - beginRect.top) / (initialPage + 1); // Check if the items are arranged in a single column or not.\n\n      var nextMultiColumn = nextPageHeight / step < endRect.height;\n      var nextPageArea = endRect.height * endRect.width * step;\n      setPageHeight(nextPageHeight);\n      setPageArea(nextPageArea);\n      setMultiColumn(nextMultiColumn);\n    }\n  }, [pageHeight, step, show]); // scroll handling\n\n  useEffect(function () {\n    var scrollParents;\n\n    var onScroll = function onScroll() {\n      var scrollParent = scrollParents[0]; // Determine the window into the first scroll parent\n\n      var top;\n      var height;\n      var width;\n\n      if (scrollParent === document) {\n        top = document.documentElement.scrollTop || document.body.scrollTop;\n        height = window.innerHeight;\n        width = window.innerWidth;\n      } else {\n        top = scrollParent.scrollTop;\n        var rect = scrollParent.getBoundingClientRect();\n        height = rect.height;\n        width = rect.width;\n      } // Figure out which pages we should make visible based on the scroll\n      // window.\n\n\n      var offset = height / 4; // nextBeginPage will increment/decrement when using replace, otherwise\n      // the beginPage will be at 0.\n\n      var nextBeginPage = replace ? Math.min(lastPage, Math.max(0, multiColumn ? Math.floor(Math.max(0, top - offset) * width / pageArea) : Math.floor(Math.max(0, top - offset) / pageHeight))) : 0; // Increment/decrement nextEndPage when nearing bounds of current page.\n      // Ensure nextEndPage contains show index initially.\n\n      var nextEndPage = Math.min(lastPage, Math.max(!replace && endPage || 0, multiColumn ? Math.ceil((top + height + offset) * width / pageArea) : Math.floor((top + height + offset) / pageHeight), show ? Math.floor(show / step) : 0));\n      if (nextBeginPage !== beginPage) setBeginPage(nextBeginPage);\n      if (nextEndPage !== endPage) setEndPage(nextEndPage);\n    };\n\n    if (pageHeight && belowMarkerRef.current) {\n      scrollParents = findScrollParents(belowMarkerRef.current);\n      scrollParents.forEach(function (scrollParent) {\n        return scrollParent.addEventListener('scroll', onScroll);\n      });\n      onScroll();\n    }\n\n    return function () {\n      if (scrollParents) {\n        scrollParents.forEach(function (scrollParent) {\n          return scrollParent.removeEventListener('scroll', onScroll);\n        });\n      }\n    };\n  }, [beginPage, endPage, lastPage, multiColumn, pageArea, pageHeight, replace, show, step]); // check if we need to ask for more\n\n  useEffect(function () {\n    if (onMore && endPage === lastPage && items.length >= pendingLength) {\n      // remember we've asked for more, so we don't keep asking if it takes\n      // a while\n      setPendingLength(items.length + 1);\n      onMore();\n    }\n  }, [endPage, items.length, lastPage, onMore, pendingLength, step]); // scroll to any 'show'\n\n  useEffect(function () {\n    // ride out any animation delays, 100ms empirically measured\n    var timer = setTimeout(function () {\n      if (show && showRef.current) {\n        var showNode = showRef.current.scrollIntoView ? showRef.current : findDOMNode(showRef.current);\n        var scrollParent = findScrollParent(showNode);\n\n        if (isNodeBeforeScroll(showNode, scrollParent)) {\n          showNode.scrollIntoView(true);\n        } else if (isNodeAfterScroll(showNode, scrollParent)) {\n          showNode.scrollIntoView(false);\n        } // clean up after having shown\n\n\n        setShow(undefined);\n      }\n    }, 100);\n    return function () {\n      return clearTimeout(timer);\n    };\n  }, [show]);\n  var firstIndex = beginPage * step;\n  var lastIndex = Math.min((endPage + 1) * step, items.length) - 1;\n  var result = [];\n\n  if (replace && pageHeight && firstIndex) {\n    var marker = /*#__PURE__*/React.createElement(Box, {\n      key: \"above\",\n      flex: false,\n      height: beginPage * pageHeight + \"px\"\n    });\n\n    if (renderMarker) {\n      // need to give it a key\n      marker = /*#__PURE__*/React.cloneElement(renderMarker(marker), {\n        key: 'above'\n      });\n    }\n\n    result.push(marker);\n  }\n\n  items.slice(firstIndex, lastIndex + 1).forEach(function (item, index) {\n    var itemsIndex = firstIndex + index;\n    var ref;\n    var child = children(item, itemsIndex, ref); // Set firstPageItemRef & lastPageItemRef if we don't know the pageHeight.\n\n    if (!pageHeight && itemsIndex === 0) {\n      // We pass the ref we want to the children render function.\n      // If we don't see that our ref was set, wrap it (\"the old way\").\n      child = children(item, itemsIndex, firstPageItemRef);\n\n      if (child.ref !== firstPageItemRef) {\n        child = /*#__PURE__*/React.createElement(Ref, {\n          key: \"first\",\n          ref: firstPageItemRef\n        }, child);\n      }\n    }\n\n    if (!pageHeight && (itemsIndex === step - 1 || itemsIndex === lastIndex)) {\n      // If show && show > step, we only want a single lastPageItemRef and it\n      // should be set at lastIndex. Ignore step - 1 scenario, otherwise will\n      // create duplicates.\n      child = show && show > step && itemsIndex === step - 1 ? child : children(item, itemsIndex, lastPageItemRef); // We pass the ref we want to the children render function.\n      // If we don't see that our ref was set, wrap it (\"the old way\").\n\n      if (child.ref !== lastPageItemRef && !(show && show > step && itemsIndex === step - 1)) {\n        child = /*#__PURE__*/React.createElement(Ref, {\n          key: \"last\",\n          ref: lastPageItemRef\n        }, child);\n      }\n    } // Set showRef\n\n\n    if (show && show === itemsIndex) {\n      child = children(item, itemsIndex, showRef);\n\n      if (child.ref !== showRef) {\n        child = /*#__PURE__*/React.createElement(Ref, {\n          key: \"show\",\n          ref: showRef\n        }, child);\n      }\n    }\n\n    result.push(child);\n  });\n\n  if (endPage < lastPage || replace || onMore) {\n    var _marker = /*#__PURE__*/React.createElement(Box, {\n      key: \"below\",\n      ref: belowMarkerRef,\n      flex: false,\n      height: (replace ? (lastPage - endPage) * pageHeight : 0) + \"px\"\n    });\n\n    if (renderMarker) {\n      // need to give it a key\n      _marker = /*#__PURE__*/React.cloneElement(renderMarker(_marker), {\n        key: 'below'\n      });\n    }\n\n    result.push(_marker);\n  }\n\n  return result;\n};\n\nvar InfiniteScrollDoc;\n\nif (process.env.NODE_ENV !== 'production') {\n  // eslint-disable-next-line global-require\n  InfiniteScrollDoc = require('./doc').doc(InfiniteScroll);\n}\n\nvar InfiniteScrollWrapper = InfiniteScrollDoc || InfiniteScroll;\nexport { InfiniteScrollWrapper as InfiniteScroll };","map":{"version":3,"sources":["/home/fromme/projects/SUSE/Sonar/npm-install-grommet/sonarscreen/node_modules/grommet/es6/components/InfiniteScroll/InfiniteScroll.js"],"names":["_inheritsLoose","subClass","superClass","prototype","Object","create","constructor","__proto__","React","Component","useEffect","useMemo","useRef","useState","findDOMNode","findScrollParent","findScrollParents","isNodeAfterScroll","isNodeBeforeScroll","Box","Ref","_Component","apply","arguments","_proto","render","children","props","InfiniteScroll","_ref","_ref$items","items","onMore","renderMarker","replace","showIndex","show","_ref$step","step","_useState","setShow","lastPage","Math","floor","length","_useState2","beginPage","setBeginPage","_useState3","endPage","setEndPage","_useState4","pageHeight","setPageHeight","_useState5","pageArea","setPageArea","_useState6","multiColumn","setMultiColumn","_useState7","pendingLength","setPendingLength","belowMarkerRef","firstPageItemRef","lastPageItemRef","showRef","current","beginRect","getBoundingClientRect","endRect","initialPage","nextPageHeight","top","height","nextMultiColumn","nextPageArea","width","scrollParents","onScroll","scrollParent","document","documentElement","scrollTop","body","window","innerHeight","innerWidth","rect","offset","nextBeginPage","min","max","nextEndPage","ceil","forEach","addEventListener","removeEventListener","timer","setTimeout","showNode","scrollIntoView","undefined","clearTimeout","firstIndex","lastIndex","result","marker","createElement","key","flex","cloneElement","push","slice","item","index","itemsIndex","ref","child","_marker","InfiniteScrollDoc","process","env","NODE_ENV","require","doc","InfiniteScrollWrapper"],"mappings":"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","sourcesContent":["function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\n/* eslint-disable react/no-find-dom-node */\nimport React, { Component, useEffect, useMemo, useRef, useState } from 'react';\nimport { findDOMNode } from 'react-dom';\nimport { findScrollParent, findScrollParents, isNodeAfterScroll, isNodeBeforeScroll } from '../../utils';\nimport { Box } from '../Box';\n\nvar Ref = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(Ref, _Component);\n\n  function Ref() {\n    return _Component.apply(this, arguments) || this;\n  }\n\n  var _proto = Ref.prototype;\n\n  _proto.render = function render() {\n    var children = this.props.children;\n    return children;\n  };\n\n  return Ref;\n}(Component);\n\nvar InfiniteScroll = function InfiniteScroll(_ref) {\n  var children = _ref.children,\n      _ref$items = _ref.items,\n      items = _ref$items === void 0 ? [] : _ref$items,\n      onMore = _ref.onMore,\n      renderMarker = _ref.renderMarker,\n      replace = _ref.replace,\n      showIndex = _ref.show,\n      _ref$step = _ref.step,\n      step = _ref$step === void 0 ? 50 : _ref$step;\n\n  // item index to be made visible initially\n  var _useState = useState(showIndex),\n      show = _useState[0],\n      setShow = _useState[1]; // the last page we have items for\n\n\n  var lastPage = useMemo(function () {\n    return Math.floor(items.length / step);\n  }, [items.length, step]); // the first page we are displaying\n\n  var _useState2 = useState(0),\n      beginPage = _useState2[0],\n      setBeginPage = _useState2[1]; // the last page we are displaying\n\n\n  var _useState3 = useState(show ? Math.floor((show + step) / step) - 1 : 0),\n      endPage = _useState3[0],\n      setEndPage = _useState3[1]; // how tall we've measured a page to be\n\n\n  var _useState4 = useState(),\n      pageHeight = _useState4[0],\n      setPageHeight = _useState4[1]; // how much area a page requires\n\n\n  var _useState5 = useState(),\n      pageArea = _useState5[0],\n      setPageArea = _useState5[1]; // whether the items are laid out in a grid instead of linearly\n\n\n  var _useState6 = useState(),\n      multiColumn = _useState6[0],\n      setMultiColumn = _useState6[1]; // what we're waiting for onMore to give us\n\n\n  var _useState7 = useState(0),\n      pendingLength = _useState7[0],\n      setPendingLength = _useState7[1];\n\n  var belowMarkerRef = useRef();\n  var firstPageItemRef = useRef();\n  var lastPageItemRef = useRef();\n  var showRef = useRef(); // calculating space based on where the first and last items being displayed\n  // are located\n\n  useEffect(function () {\n    if (firstPageItemRef.current && lastPageItemRef.current && !pageHeight) {\n      /* eslint-disable react/no-find-dom-node */\n      var beginRect = firstPageItemRef.current.getBoundingClientRect ? firstPageItemRef.current.getBoundingClientRect() : findDOMNode(firstPageItemRef.current).getBoundingClientRect();\n      var endRect = lastPageItemRef.current.getBoundingClientRect ? lastPageItemRef.current.getBoundingClientRect() : findDOMNode(lastPageItemRef.current).getBoundingClientRect(); // Need to adjust for cases such as show where first and last page item\n      // refs can be much larger than the step.\n\n      var initialPage = show ? Math.floor(show / step) : 0;\n      var nextPageHeight = (endRect.top + endRect.height - beginRect.top) / (initialPage + 1); // Check if the items are arranged in a single column or not.\n\n      var nextMultiColumn = nextPageHeight / step < endRect.height;\n      var nextPageArea = endRect.height * endRect.width * step;\n      setPageHeight(nextPageHeight);\n      setPageArea(nextPageArea);\n      setMultiColumn(nextMultiColumn);\n    }\n  }, [pageHeight, step, show]); // scroll handling\n\n  useEffect(function () {\n    var scrollParents;\n\n    var onScroll = function onScroll() {\n      var scrollParent = scrollParents[0]; // Determine the window into the first scroll parent\n\n      var top;\n      var height;\n      var width;\n\n      if (scrollParent === document) {\n        top = document.documentElement.scrollTop || document.body.scrollTop;\n        height = window.innerHeight;\n        width = window.innerWidth;\n      } else {\n        top = scrollParent.scrollTop;\n        var rect = scrollParent.getBoundingClientRect();\n        height = rect.height;\n        width = rect.width;\n      } // Figure out which pages we should make visible based on the scroll\n      // window.\n\n\n      var offset = height / 4; // nextBeginPage will increment/decrement when using replace, otherwise\n      // the beginPage will be at 0.\n\n      var nextBeginPage = replace ? Math.min(lastPage, Math.max(0, multiColumn ? Math.floor(Math.max(0, top - offset) * width / pageArea) : Math.floor(Math.max(0, top - offset) / pageHeight))) : 0; // Increment/decrement nextEndPage when nearing bounds of current page.\n      // Ensure nextEndPage contains show index initially.\n\n      var nextEndPage = Math.min(lastPage, Math.max(!replace && endPage || 0, multiColumn ? Math.ceil((top + height + offset) * width / pageArea) : Math.floor((top + height + offset) / pageHeight), show ? Math.floor(show / step) : 0));\n      if (nextBeginPage !== beginPage) setBeginPage(nextBeginPage);\n      if (nextEndPage !== endPage) setEndPage(nextEndPage);\n    };\n\n    if (pageHeight && belowMarkerRef.current) {\n      scrollParents = findScrollParents(belowMarkerRef.current);\n      scrollParents.forEach(function (scrollParent) {\n        return scrollParent.addEventListener('scroll', onScroll);\n      });\n      onScroll();\n    }\n\n    return function () {\n      if (scrollParents) {\n        scrollParents.forEach(function (scrollParent) {\n          return scrollParent.removeEventListener('scroll', onScroll);\n        });\n      }\n    };\n  }, [beginPage, endPage, lastPage, multiColumn, pageArea, pageHeight, replace, show, step]); // check if we need to ask for more\n\n  useEffect(function () {\n    if (onMore && endPage === lastPage && items.length >= pendingLength) {\n      // remember we've asked for more, so we don't keep asking if it takes\n      // a while\n      setPendingLength(items.length + 1);\n      onMore();\n    }\n  }, [endPage, items.length, lastPage, onMore, pendingLength, step]); // scroll to any 'show'\n\n  useEffect(function () {\n    // ride out any animation delays, 100ms empirically measured\n    var timer = setTimeout(function () {\n      if (show && showRef.current) {\n        var showNode = showRef.current.scrollIntoView ? showRef.current : findDOMNode(showRef.current);\n        var scrollParent = findScrollParent(showNode);\n\n        if (isNodeBeforeScroll(showNode, scrollParent)) {\n          showNode.scrollIntoView(true);\n        } else if (isNodeAfterScroll(showNode, scrollParent)) {\n          showNode.scrollIntoView(false);\n        } // clean up after having shown\n\n\n        setShow(undefined);\n      }\n    }, 100);\n    return function () {\n      return clearTimeout(timer);\n    };\n  }, [show]);\n  var firstIndex = beginPage * step;\n  var lastIndex = Math.min((endPage + 1) * step, items.length) - 1;\n  var result = [];\n\n  if (replace && pageHeight && firstIndex) {\n    var marker = /*#__PURE__*/React.createElement(Box, {\n      key: \"above\",\n      flex: false,\n      height: beginPage * pageHeight + \"px\"\n    });\n\n    if (renderMarker) {\n      // need to give it a key\n      marker = /*#__PURE__*/React.cloneElement(renderMarker(marker), {\n        key: 'above'\n      });\n    }\n\n    result.push(marker);\n  }\n\n  items.slice(firstIndex, lastIndex + 1).forEach(function (item, index) {\n    var itemsIndex = firstIndex + index;\n    var ref;\n    var child = children(item, itemsIndex, ref); // Set firstPageItemRef & lastPageItemRef if we don't know the pageHeight.\n\n    if (!pageHeight && itemsIndex === 0) {\n      // We pass the ref we want to the children render function.\n      // If we don't see that our ref was set, wrap it (\"the old way\").\n      child = children(item, itemsIndex, firstPageItemRef);\n\n      if (child.ref !== firstPageItemRef) {\n        child = /*#__PURE__*/React.createElement(Ref, {\n          key: \"first\",\n          ref: firstPageItemRef\n        }, child);\n      }\n    }\n\n    if (!pageHeight && (itemsIndex === step - 1 || itemsIndex === lastIndex)) {\n      // If show && show > step, we only want a single lastPageItemRef and it\n      // should be set at lastIndex. Ignore step - 1 scenario, otherwise will\n      // create duplicates.\n      child = show && show > step && itemsIndex === step - 1 ? child : children(item, itemsIndex, lastPageItemRef); // We pass the ref we want to the children render function.\n      // If we don't see that our ref was set, wrap it (\"the old way\").\n\n      if (child.ref !== lastPageItemRef && !(show && show > step && itemsIndex === step - 1)) {\n        child = /*#__PURE__*/React.createElement(Ref, {\n          key: \"last\",\n          ref: lastPageItemRef\n        }, child);\n      }\n    } // Set showRef\n\n\n    if (show && show === itemsIndex) {\n      child = children(item, itemsIndex, showRef);\n\n      if (child.ref !== showRef) {\n        child = /*#__PURE__*/React.createElement(Ref, {\n          key: \"show\",\n          ref: showRef\n        }, child);\n      }\n    }\n\n    result.push(child);\n  });\n\n  if (endPage < lastPage || replace || onMore) {\n    var _marker = /*#__PURE__*/React.createElement(Box, {\n      key: \"below\",\n      ref: belowMarkerRef,\n      flex: false,\n      height: (replace ? (lastPage - endPage) * pageHeight : 0) + \"px\"\n    });\n\n    if (renderMarker) {\n      // need to give it a key\n      _marker = /*#__PURE__*/React.cloneElement(renderMarker(_marker), {\n        key: 'below'\n      });\n    }\n\n    result.push(_marker);\n  }\n\n  return result;\n};\n\nvar InfiniteScrollDoc;\n\nif (process.env.NODE_ENV !== 'production') {\n  // eslint-disable-next-line global-require\n  InfiniteScrollDoc = require('./doc').doc(InfiniteScroll);\n}\n\nvar InfiniteScrollWrapper = InfiniteScrollDoc || InfiniteScroll;\nexport { InfiniteScrollWrapper as InfiniteScroll };"]},"metadata":{},"sourceType":"module"}